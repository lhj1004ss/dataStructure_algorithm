<!-- Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

 

Example 1:

Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
Example 2:

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
 
 -->

<script>
  /**
   * @param {number[]} nums
   * @param {number} k
   * @return {number}
   */
  // time: O(n) ,  space: O(1)
  var longestOnes = function (nums, k) {
    let left = 0
    let right = 0
    let maxLength = -Infinity
    let count = 0

    while (right < nums.length) {
      if (nums[right] === 0) {
        count++
      }

      while (count > k) {
        if (nums[left] === 0) {
          count--
        }
        left++
      }
      maxLength = Math.max(maxLength, right - left + 1)
      right++
    }

    return maxLength

    // time: O(n) ,  space: O(n)

    // let map = new Map()
    // let left = 0
    // let right = 0
    // let maxLength = 0
    // while (right < nums.length) {
    //   if (map.has(nums[right])) {
    //     map.set(nums[right], map.get(nums[right]) + 1)
    //   } else {
    //     map.set(nums[right], 1)
    //   }
    //   if (map.get(0) > k) {
    //     if (map.get(0) > 1) {
    //       map.set(nums[left], map.get(nums[left]) - 1)
    //     } else {
    //       map.delete(nums[left])
    //     }
    //     left++
    //   }
    //   maxLength = Math.max(maxLength, right - left + 1)
    //   right++
    // }
    // return maxLength
  }
  longestOnes([1, 1, 1, 0, 0, 0])
</script>
